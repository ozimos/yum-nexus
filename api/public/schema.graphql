### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Address {
  areaCode: Int!
  createdAt: DateTime!
  id: String!
  lga: String!
  state: String!
  updatedAt: DateTime!
}

input AddressCreateManyWithoutUserInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutUserInput!]
}

input AddressCreateOneWithoutDefaultAddressInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutDefaultAddressInput
}

input AddressCreateWithoutDefaultAddressInput {
  areaCode: Int!
  createdAt: DateTime
  id: String
  lga: String!
  state: String!
  street1: String!
  street2: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutAddressesInput!
}

input AddressCreateWithoutUserInput {
  areaCode: Int!
  createdAt: DateTime
  DefaultAddress: DefaultAddressCreateManyWithoutAddressInput
  id: String
  lga: String!
  state: String!
  street1: String!
  street2: String!
  updatedAt: DateTime
}

input AddressFilter {
  every: AddressWhereInput
  none: AddressWhereInput
  some: AddressWhereInput
}

input AddressMineCompoundUniqueInput {
  id: String!
  userId: String!
}

input AddressScalarWhereInput {
  AND: [AddressScalarWhereInput!]
  areaCode: IntFilter
  createdAt: DateTimeFilter
  DefaultAddress: DefaultAddressFilter
  id: StringFilter
  lga: StringFilter
  NOT: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  state: StringFilter
  street1: StringFilter
  street2: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input AddressUpdateManyDataInput {
  areaCode: Int
  createdAt: DateTime
  id: String
  lga: String
  state: String
  street1: String
  street2: String
  updatedAt: DateTime
}

input AddressUpdateManyWithoutUserInput {
  connect: [AddressWhereUniqueInput!]
  create: [AddressCreateWithoutUserInput!]
  delete: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  disconnect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutUserInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  data: AddressUpdateManyDataInput!
  where: AddressScalarWhereInput!
}

input AddressUpdateOneRequiredWithoutDefaultAddressInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutDefaultAddressInput
  update: AddressUpdateWithoutDefaultAddressDataInput
  upsert: AddressUpsertWithoutDefaultAddressInput
}

input AddressUpdateWithoutDefaultAddressDataInput {
  areaCode: Int
  createdAt: DateTime
  id: String
  lga: String
  state: String
  street1: String
  street2: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutAddressesInput
}

input AddressUpdateWithoutUserDataInput {
  areaCode: Int
  createdAt: DateTime
  DefaultAddress: DefaultAddressUpdateManyWithoutAddressInput
  id: String
  lga: String
  state: String
  street1: String
  street2: String
  updatedAt: DateTime
}

input AddressUpdateWithWhereUniqueWithoutUserInput {
  data: AddressUpdateWithoutUserDataInput!
  where: AddressWhereUniqueInput!
}

input AddressUpsertWithoutDefaultAddressInput {
  create: AddressCreateWithoutDefaultAddressInput!
  update: AddressUpdateWithoutDefaultAddressDataInput!
}

input AddressUpsertWithWhereUniqueWithoutUserInput {
  create: AddressCreateWithoutUserInput!
  update: AddressUpdateWithoutUserDataInput!
  where: AddressWhereUniqueInput!
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  areaCode: IntFilter
  createdAt: DateTimeFilter
  DefaultAddress: DefaultAddressFilter
  id: StringFilter
  lga: StringFilter
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  state: StringFilter
  street1: StringFilter
  street2: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input AddressWhereUniqueInput {
  addressMine: AddressMineCompoundUniqueInput
  id: String
}

type AuthPayload {
  accessToken: String
  user: User
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input DefaultAddressCreateManyWithoutAddressInput {
  connect: [DefaultAddressWhereUniqueInput!]
  create: [DefaultAddressCreateWithoutAddressInput!]
}

input DefaultAddressCreateOneWithoutUserInput {
  connect: DefaultAddressWhereUniqueInput
  create: DefaultAddressCreateWithoutUserInput
}

input DefaultAddressCreateWithoutAddressInput {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  user: UserCreateOneWithoutDefaultAddressInput!
}

input DefaultAddressCreateWithoutUserInput {
  address: AddressCreateOneWithoutDefaultAddressInput!
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input DefaultAddressFilter {
  every: DefaultAddressWhereInput
  none: DefaultAddressWhereInput
  some: DefaultAddressWhereInput
}

input DefaultAddressScalarWhereInput {
  addressId: StringFilter
  AND: [DefaultAddressScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [DefaultAddressScalarWhereInput!]
  OR: [DefaultAddressScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input DefaultAddressUpdateManyDataInput {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input DefaultAddressUpdateManyWithoutAddressInput {
  connect: [DefaultAddressWhereUniqueInput!]
  create: [DefaultAddressCreateWithoutAddressInput!]
  delete: [DefaultAddressWhereUniqueInput!]
  deleteMany: [DefaultAddressScalarWhereInput!]
  disconnect: [DefaultAddressWhereUniqueInput!]
  set: [DefaultAddressWhereUniqueInput!]
  update: [DefaultAddressUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [DefaultAddressUpdateManyWithWhereNestedInput!]
  upsert: [DefaultAddressUpsertWithWhereUniqueWithoutAddressInput!]
}

input DefaultAddressUpdateManyWithWhereNestedInput {
  data: DefaultAddressUpdateManyDataInput!
  where: DefaultAddressScalarWhereInput!
}

input DefaultAddressUpdateOneWithoutUserInput {
  connect: DefaultAddressWhereUniqueInput
  create: DefaultAddressCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: DefaultAddressUpdateWithoutUserDataInput
  upsert: DefaultAddressUpsertWithoutUserInput
}

input DefaultAddressUpdateWithoutAddressDataInput {
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutDefaultAddressInput
}

input DefaultAddressUpdateWithoutUserDataInput {
  address: AddressUpdateOneRequiredWithoutDefaultAddressInput
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input DefaultAddressUpdateWithWhereUniqueWithoutAddressInput {
  data: DefaultAddressUpdateWithoutAddressDataInput!
  where: DefaultAddressWhereUniqueInput!
}

input DefaultAddressUpsertWithoutUserInput {
  create: DefaultAddressCreateWithoutUserInput!
  update: DefaultAddressUpdateWithoutUserDataInput!
}

input DefaultAddressUpsertWithWhereUniqueWithoutAddressInput {
  create: DefaultAddressCreateWithoutAddressInput!
  update: DefaultAddressUpdateWithoutAddressDataInput!
  where: DefaultAddressWhereUniqueInput!
}

input DefaultAddressWhereInput {
  address: AddressWhereInput
  addressId: StringFilter
  AND: [DefaultAddressWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [DefaultAddressWhereInput!]
  OR: [DefaultAddressWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input DefaultAddressWhereUniqueInput {
  id: String
  userId: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type LogoutResponse {
  accessToken: String
}

type Meal {
  createdAt: DateTime!
  description: String!
  id: String!
  price: Int!
  title: String!
  updatedAt: DateTime!
  user: User!
}

input MealCreateInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String!
  id: String
  imageUrl: String!
  menus: MenuCreateManyWithoutMealsInput
  orders: MealsOnOrdersCreateManyWithoutMealInput
  price: Int!
  tags: MealCreatetagsInput
  title: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutMealsInput!
}

input MealCreateManyWithoutMenusInput {
  connect: [MealWhereUniqueInput!]
  create: [MealCreateWithoutMenusInput!]
}

input MealCreateManyWithoutUserInput {
  connect: [MealWhereUniqueInput!]
  create: [MealCreateWithoutUserInput!]
}

input MealCreateOneWithoutOrdersInput {
  connect: MealWhereUniqueInput
  create: MealCreateWithoutOrdersInput
}

input MealCreatetagsInput {
  set: [String!]
}

input MealCreateWithoutMenusInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String!
  id: String
  imageUrl: String!
  orders: MealsOnOrdersCreateManyWithoutMealInput
  price: Int!
  tags: MealCreatetagsInput
  title: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutMealsInput!
}

input MealCreateWithoutOrdersInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String!
  id: String
  imageUrl: String!
  menus: MenuCreateManyWithoutMealsInput
  price: Int!
  tags: MealCreatetagsInput
  title: String!
  updatedAt: DateTime
  user: UserCreateOneWithoutMealsInput!
}

input MealCreateWithoutUserInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String!
  id: String
  imageUrl: String!
  menus: MenuCreateManyWithoutMealsInput
  orders: MealsOnOrdersCreateManyWithoutMealInput
  price: Int!
  tags: MealCreatetagsInput
  title: String!
  updatedAt: DateTime
}

input MealFilter {
  every: MealWhereInput
  none: MealWhereInput
  some: MealWhereInput
}

input MealMineCompoundUniqueInput {
  id: String!
  userId: String!
}

input MealScalarWhereInput {
  AND: [MealScalarWhereInput!]
  createdAt: DateTimeFilter
  deletedAt: NullableDateTimeFilter
  description: StringFilter
  id: StringFilter
  imageUrl: StringFilter
  menus: MenuFilter
  NOT: [MealScalarWhereInput!]
  OR: [MealScalarWhereInput!]
  orders: MealsOnOrdersFilter
  price: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

type MealsOnOrders {
  id: String!
  meal: Meal!
  mealId: String!
  order: Order!
  orderId: String!
}

input MealsOnOrdersCompoundUniqueInput {
  mealId: String!
  orderId: String!
}

input MealsOnOrdersCreateManyWithoutMealInput {
  connect: [MealsOnOrdersWhereUniqueInput!]
  create: [MealsOnOrdersCreateWithoutMealInput!]
}

input MealsOnOrdersCreateManyWithoutOrderInput {
  connect: [MealsOnOrdersWhereUniqueInput!]
  create: [MealsOnOrdersCreateWithoutOrderInput!]
}

input MealsOnOrdersCreateWithoutMealInput {
  createdAt: DateTime
  id: String
  order: OrderCreateOneWithoutMealsInput!
  quantity: Int
  updatedAt: DateTime
}

input MealsOnOrdersCreateWithoutOrderInput {
  createdAt: DateTime
  id: String
  meal: MealCreateOneWithoutOrdersInput!
  quantity: Int
  updatedAt: DateTime
}

input MealsOnOrdersFilter {
  every: MealsOnOrdersWhereInput
  none: MealsOnOrdersWhereInput
  some: MealsOnOrdersWhereInput
}

input MealsOnOrdersScalarWhereInput {
  AND: [MealsOnOrdersScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  mealId: StringFilter
  NOT: [MealsOnOrdersScalarWhereInput!]
  OR: [MealsOnOrdersScalarWhereInput!]
  orderId: StringFilter
  quantity: IntFilter
  updatedAt: DateTimeFilter
}

input MealsOnOrdersUpdateManyDataInput {
  createdAt: DateTime
  id: String
  quantity: Int
  updatedAt: DateTime
}

input MealsOnOrdersUpdateManyWithoutMealInput {
  connect: [MealsOnOrdersWhereUniqueInput!]
  create: [MealsOnOrdersCreateWithoutMealInput!]
  delete: [MealsOnOrdersWhereUniqueInput!]
  deleteMany: [MealsOnOrdersScalarWhereInput!]
  disconnect: [MealsOnOrdersWhereUniqueInput!]
  set: [MealsOnOrdersWhereUniqueInput!]
  update: [MealsOnOrdersUpdateWithWhereUniqueWithoutMealInput!]
  updateMany: [MealsOnOrdersUpdateManyWithWhereNestedInput!]
  upsert: [MealsOnOrdersUpsertWithWhereUniqueWithoutMealInput!]
}

input MealsOnOrdersUpdateManyWithoutOrderInput {
  connect: [MealsOnOrdersWhereUniqueInput!]
  create: [MealsOnOrdersCreateWithoutOrderInput!]
  delete: [MealsOnOrdersWhereUniqueInput!]
  deleteMany: [MealsOnOrdersScalarWhereInput!]
  disconnect: [MealsOnOrdersWhereUniqueInput!]
  set: [MealsOnOrdersWhereUniqueInput!]
  update: [MealsOnOrdersUpdateWithWhereUniqueWithoutOrderInput!]
  updateMany: [MealsOnOrdersUpdateManyWithWhereNestedInput!]
  upsert: [MealsOnOrdersUpsertWithWhereUniqueWithoutOrderInput!]
}

input MealsOnOrdersUpdateManyWithWhereNestedInput {
  data: MealsOnOrdersUpdateManyDataInput!
  where: MealsOnOrdersScalarWhereInput!
}

input MealsOnOrdersUpdateWithoutMealDataInput {
  createdAt: DateTime
  id: String
  order: OrderUpdateOneRequiredWithoutMealsInput
  quantity: Int
  updatedAt: DateTime
}

input MealsOnOrdersUpdateWithoutOrderDataInput {
  createdAt: DateTime
  id: String
  meal: MealUpdateOneRequiredWithoutOrdersInput
  quantity: Int
  updatedAt: DateTime
}

input MealsOnOrdersUpdateWithWhereUniqueWithoutMealInput {
  data: MealsOnOrdersUpdateWithoutMealDataInput!
  where: MealsOnOrdersWhereUniqueInput!
}

input MealsOnOrdersUpdateWithWhereUniqueWithoutOrderInput {
  data: MealsOnOrdersUpdateWithoutOrderDataInput!
  where: MealsOnOrdersWhereUniqueInput!
}

input MealsOnOrdersUpsertWithWhereUniqueWithoutMealInput {
  create: MealsOnOrdersCreateWithoutMealInput!
  update: MealsOnOrdersUpdateWithoutMealDataInput!
  where: MealsOnOrdersWhereUniqueInput!
}

input MealsOnOrdersUpsertWithWhereUniqueWithoutOrderInput {
  create: MealsOnOrdersCreateWithoutOrderInput!
  update: MealsOnOrdersUpdateWithoutOrderDataInput!
  where: MealsOnOrdersWhereUniqueInput!
}

input MealsOnOrdersWhereInput {
  AND: [MealsOnOrdersWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  meal: MealWhereInput
  mealId: StringFilter
  NOT: [MealsOnOrdersWhereInput!]
  OR: [MealsOnOrdersWhereInput!]
  order: OrderWhereInput
  orderId: StringFilter
  quantity: IntFilter
  updatedAt: DateTimeFilter
}

input MealsOnOrdersWhereUniqueInput {
  id: String
  mealsOnOrders: MealsOnOrdersCompoundUniqueInput
}

input MealUpdateInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: String
  imageUrl: String
  menus: MenuUpdateManyWithoutMealsInput
  orders: MealsOnOrdersUpdateManyWithoutMealInput
  price: Int
  tags: MealUpdatetagsInput
  title: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutMealsInput
}

input MealUpdateManyDataInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: String
  imageUrl: String
  price: Int
  tags: MealUpdatetagsInput
  title: String
  updatedAt: DateTime
}

input MealUpdateManyWithoutMenusInput {
  connect: [MealWhereUniqueInput!]
  create: [MealCreateWithoutMenusInput!]
  delete: [MealWhereUniqueInput!]
  deleteMany: [MealScalarWhereInput!]
  disconnect: [MealWhereUniqueInput!]
  set: [MealWhereUniqueInput!]
  update: [MealUpdateWithWhereUniqueWithoutMenusInput!]
  updateMany: [MealUpdateManyWithWhereNestedInput!]
  upsert: [MealUpsertWithWhereUniqueWithoutMenusInput!]
}

input MealUpdateManyWithoutUserInput {
  connect: [MealWhereUniqueInput!]
  create: [MealCreateWithoutUserInput!]
  delete: [MealWhereUniqueInput!]
  deleteMany: [MealScalarWhereInput!]
  disconnect: [MealWhereUniqueInput!]
  set: [MealWhereUniqueInput!]
  update: [MealUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [MealUpdateManyWithWhereNestedInput!]
  upsert: [MealUpsertWithWhereUniqueWithoutUserInput!]
}

input MealUpdateManyWithWhereNestedInput {
  data: MealUpdateManyDataInput!
  where: MealScalarWhereInput!
}

input MealUpdateOneRequiredWithoutOrdersInput {
  connect: MealWhereUniqueInput
  create: MealCreateWithoutOrdersInput
  update: MealUpdateWithoutOrdersDataInput
  upsert: MealUpsertWithoutOrdersInput
}

input MealUpdatetagsInput {
  set: [String!]
}

input MealUpdateWithoutMenusDataInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: String
  imageUrl: String
  orders: MealsOnOrdersUpdateManyWithoutMealInput
  price: Int
  tags: MealUpdatetagsInput
  title: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutMealsInput
}

input MealUpdateWithoutOrdersDataInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: String
  imageUrl: String
  menus: MenuUpdateManyWithoutMealsInput
  price: Int
  tags: MealUpdatetagsInput
  title: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutMealsInput
}

input MealUpdateWithoutUserDataInput {
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: String
  imageUrl: String
  menus: MenuUpdateManyWithoutMealsInput
  orders: MealsOnOrdersUpdateManyWithoutMealInput
  price: Int
  tags: MealUpdatetagsInput
  title: String
  updatedAt: DateTime
}

input MealUpdateWithWhereUniqueWithoutMenusInput {
  data: MealUpdateWithoutMenusDataInput!
  where: MealWhereUniqueInput!
}

input MealUpdateWithWhereUniqueWithoutUserInput {
  data: MealUpdateWithoutUserDataInput!
  where: MealWhereUniqueInput!
}

input MealUpsertWithoutOrdersInput {
  create: MealCreateWithoutOrdersInput!
  update: MealUpdateWithoutOrdersDataInput!
}

input MealUpsertWithWhereUniqueWithoutMenusInput {
  create: MealCreateWithoutMenusInput!
  update: MealUpdateWithoutMenusDataInput!
  where: MealWhereUniqueInput!
}

input MealUpsertWithWhereUniqueWithoutUserInput {
  create: MealCreateWithoutUserInput!
  update: MealUpdateWithoutUserDataInput!
  where: MealWhereUniqueInput!
}

input MealWhereInput {
  AND: [MealWhereInput!]
  createdAt: DateTimeFilter
  deletedAt: NullableDateTimeFilter
  description: StringFilter
  id: StringFilter
  imageUrl: StringFilter
  menus: MenuFilter
  NOT: [MealWhereInput!]
  OR: [MealWhereInput!]
  orders: MealsOnOrdersFilter
  price: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input MealWhereUniqueInput {
  id: String
  mealMine: MealMineCompoundUniqueInput
}

type Menu {
  createdAt: DateTime!
  id: String!
  meals(after: MealWhereUniqueInput, before: MealWhereUniqueInput, first: Int, last: Int, skip: Int): [Meal!]!
  menuDate: DateTime!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input MenuCreateInput {
  createdAt: DateTime
  id: String
  meals: MealCreateManyWithoutMenusInput
  menuDate: DateTime!
  updatedAt: DateTime
  user: UserCreateOneWithoutMenusInput!
}

input MenuCreateManyWithoutMealsInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutMealsInput!]
}

input MenuCreateManyWithoutUserInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutUserInput!]
}

input MenuCreateWithoutMealsInput {
  createdAt: DateTime
  id: String
  menuDate: DateTime!
  updatedAt: DateTime
  user: UserCreateOneWithoutMenusInput!
}

input MenuCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  meals: MealCreateManyWithoutMenusInput
  menuDate: DateTime!
  updatedAt: DateTime
}

input MenuFilter {
  every: MenuWhereInput
  none: MenuWhereInput
  some: MenuWhereInput
}

input MenuMineCompoundUniqueInput {
  menuDate: DateTime!
  userId: String!
}

input MenuScalarWhereInput {
  AND: [MenuScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  meals: MealFilter
  menuDate: DateTimeFilter
  NOT: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input MenuUpdateInput {
  createdAt: DateTime
  id: String
  meals: MealUpdateManyWithoutMenusInput
  menuDate: DateTime
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutMenusInput
}

input MenuUpdateManyDataInput {
  createdAt: DateTime
  id: String
  menuDate: DateTime
  updatedAt: DateTime
}

input MenuUpdateManyWithoutMealsInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutMealsInput!]
  delete: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  disconnect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutMealsInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutMealsInput!]
}

input MenuUpdateManyWithoutUserInput {
  connect: [MenuWhereUniqueInput!]
  create: [MenuCreateWithoutUserInput!]
  delete: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  disconnect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutUserInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  data: MenuUpdateManyDataInput!
  where: MenuScalarWhereInput!
}

input MenuUpdateWithoutMealsDataInput {
  createdAt: DateTime
  id: String
  menuDate: DateTime
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutMenusInput
}

input MenuUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: String
  meals: MealUpdateManyWithoutMenusInput
  menuDate: DateTime
  updatedAt: DateTime
}

input MenuUpdateWithWhereUniqueWithoutMealsInput {
  data: MenuUpdateWithoutMealsDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpdateWithWhereUniqueWithoutUserInput {
  data: MenuUpdateWithoutUserDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutMealsInput {
  create: MenuCreateWithoutMealsInput!
  update: MenuUpdateWithoutMealsDataInput!
  where: MenuWhereUniqueInput!
}

input MenuUpsertWithWhereUniqueWithoutUserInput {
  create: MenuCreateWithoutUserInput!
  update: MenuUpdateWithoutUserDataInput!
  where: MenuWhereUniqueInput!
}

input MenuWhereInput {
  AND: [MenuWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  meals: MealFilter
  menuDate: DateTimeFilter
  NOT: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input MenuWhereUniqueInput {
  id: String
  menuMine: MenuMineCompoundUniqueInput
}

type Mutation {
  createOneMeal(data: MealCreateInput!): Meal!
  createOneMenu(data: MenuCreateInput!): Menu!
  createOneOrder(data: OrderCreateInput!): Order!
  createOneOwnMeal(data: MealCreateInput!): Meal!
  createOneOwnMenu(data: MenuCreateInput!): Menu!
  createOneOwnOrder(data: OrderCreateInput!): Order!
  deleteOneMeal(where: MealWhereUniqueInput!): Meal
  deleteOneMenu(where: MenuWhereUniqueInput!): Menu
  deleteOneOrder(where: OrderWhereUniqueInput!): Order
  deleteOneOwnMeal(where: MealWhereUniqueInput!): Meal
  deleteOneOwnMenu(where: MenuWhereUniqueInput!): Menu
  deleteOneOwnOrder(where: OrderWhereUniqueInput!): Order
  deleteOneOwnUser(where: UserWhereUniqueInput!): User
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  loginWithFaceBook(token: String!): AuthPayload
  loginWithGoogle(token: String!): AuthPayload
  logout: LogoutResponse
  revokeUserRefreshToken(user: UserWhereUniqueInput): User
  signup(email: String!, firstName: String, lastName: String, password: String!): AuthPayload
  updateOneMeal(data: MealUpdateInput!, where: MealWhereUniqueInput!): Meal
  updateOneMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateOneOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateOneOwnMeal(data: MealUpdateInput!, where: MealWhereUniqueInput!): Meal
  updateOneOwnMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateOneOwnOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateOneOwnUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Order {
  createdAt: DateTime!
  id: String!
  meals(after: MealsOnOrdersWhereUniqueInput, before: MealsOnOrdersWhereUniqueInput, first: Int, last: Int, skip: Int): [MealsOnOrders!]!
  status: Status!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

enum OrderByArg {
  asc
  desc
}

input OrderCreateInput {
  createdAt: DateTime
  id: String
  meals: MealsOnOrdersCreateManyWithoutOrderInput
  status: Status
  updatedAt: DateTime
  user: UserCreateOneWithoutOrdersInput!
}

input OrderCreateManyWithoutUserInput {
  connect: [OrderWhereUniqueInput!]
  create: [OrderCreateWithoutUserInput!]
}

input OrderCreateOneWithoutMealsInput {
  connect: OrderWhereUniqueInput
  create: OrderCreateWithoutMealsInput
}

input OrderCreateWithoutMealsInput {
  createdAt: DateTime
  id: String
  status: Status
  updatedAt: DateTime
  user: UserCreateOneWithoutOrdersInput!
}

input OrderCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  meals: MealsOnOrdersCreateManyWithoutOrderInput
  status: Status
  updatedAt: DateTime
}

input OrderFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

input OrderMineCompoundUniqueInput {
  id: String!
  userId: String!
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  meals: MealsOnOrdersFilter
  NOT: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  status: Status
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input OrderUpdateInput {
  createdAt: DateTime
  id: String
  meals: MealsOnOrdersUpdateManyWithoutOrderInput
  status: Status
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutOrdersInput
}

input OrderUpdateManyDataInput {
  createdAt: DateTime
  id: String
  status: Status
  updatedAt: DateTime
}

input OrderUpdateManyWithoutUserInput {
  connect: [OrderWhereUniqueInput!]
  create: [OrderCreateWithoutUserInput!]
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutUserInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  data: OrderUpdateManyDataInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateOneRequiredWithoutMealsInput {
  connect: OrderWhereUniqueInput
  create: OrderCreateWithoutMealsInput
  update: OrderUpdateWithoutMealsDataInput
  upsert: OrderUpsertWithoutMealsInput
}

input OrderUpdateWithoutMealsDataInput {
  createdAt: DateTime
  id: String
  status: Status
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutOrdersInput
}

input OrderUpdateWithoutUserDataInput {
  createdAt: DateTime
  id: String
  meals: MealsOnOrdersUpdateManyWithoutOrderInput
  status: Status
  updatedAt: DateTime
}

input OrderUpdateWithWhereUniqueWithoutUserInput {
  data: OrderUpdateWithoutUserDataInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithoutMealsInput {
  create: OrderCreateWithoutMealsInput!
  update: OrderUpdateWithoutMealsDataInput!
}

input OrderUpsertWithWhereUniqueWithoutUserInput {
  create: OrderCreateWithoutUserInput!
  update: OrderUpdateWithoutUserDataInput!
  where: OrderWhereUniqueInput!
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  meals: MealsOnOrdersFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  status: Status
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
  orderMine: OrderMineCompoundUniqueInput
}

type Query {
  me: User
  meal(where: MealWhereUniqueInput!): Meal
  meals(after: MealWhereUniqueInput, before: MealWhereUniqueInput, first: Int, last: Int, skip: Int, where: MealWhereInput): [Meal!]!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(after: MenuWhereUniqueInput, before: MenuWhereUniqueInput, first: Int, last: Int, skip: Int, where: MenuWhereInput): [Menu!]!
  order(where: OrderWhereUniqueInput!): Order
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int, skip: Int, where: OrderWhereInput): [Order!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int): [User!]!
}

enum Role {
  ADMIN
  CATERER
  USER
}

enum Status {
  DISPATCHED
  FULFILLED
  PENDING
  PROCESSING
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type TokenUser {
  id: String
  role: String
  tokenVersion: String
}

type User {
  addresses(first: Int): [Address!]!
  createdAt: DateTime!
  email: String!
  firstName: String
  id: String!
  lastName: String
  meals(after: MealWhereUniqueInput, before: MealWhereUniqueInput, first: Int, last: Int, skip: Int): [Meal!]!
  role: Role!
  tokenVersion: String!
  updatedAt: DateTime!
}

input UserCreateOneWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
}

input UserCreateOneWithoutDefaultAddressInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDefaultAddressInput
}

input UserCreateOneWithoutMealsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutMealsInput
}

input UserCreateOneWithoutMenusInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutMenusInput
}

input UserCreateOneWithoutOrdersInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutOrdersInput
}

input UserCreateWithoutAddressesInput {
  createdAt: DateTime
  defaultAddress: DefaultAddressCreateOneWithoutUserInput
  email: String!
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealCreateManyWithoutUserInput
  menus: MenuCreateManyWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserCreateWithoutDefaultAddressInput {
  addresses: AddressCreateManyWithoutUserInput
  createdAt: DateTime
  email: String!
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealCreateManyWithoutUserInput
  menus: MenuCreateManyWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserCreateWithoutMealsInput {
  addresses: AddressCreateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressCreateOneWithoutUserInput
  email: String!
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  menus: MenuCreateManyWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserCreateWithoutMenusInput {
  addresses: AddressCreateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressCreateOneWithoutUserInput
  email: String!
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealCreateManyWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserCreateWithoutOrdersInput {
  addresses: AddressCreateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressCreateOneWithoutUserInput
  email: String!
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealCreateManyWithoutUserInput
  menus: MenuCreateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: OrderByArg
  email: OrderByArg
  facebookId: OrderByArg
  firstName: OrderByArg
  googleId: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  password: OrderByArg
  role: OrderByArg
  tokenVersion: OrderByArg
  updatedAt: OrderByArg
}

input UserUpdateInput {
  addresses: AddressUpdateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressUpdateOneWithoutUserInput
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealUpdateManyWithoutUserInput
  menus: MenuUpdateManyWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutAddressesInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutAddressesInput
  update: UserUpdateWithoutAddressesDataInput
  upsert: UserUpsertWithoutAddressesInput
}

input UserUpdateOneRequiredWithoutDefaultAddressInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutDefaultAddressInput
  update: UserUpdateWithoutDefaultAddressDataInput
  upsert: UserUpsertWithoutDefaultAddressInput
}

input UserUpdateOneRequiredWithoutMealsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutMealsInput
  update: UserUpdateWithoutMealsDataInput
  upsert: UserUpsertWithoutMealsInput
}

input UserUpdateOneRequiredWithoutMenusInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutMenusInput
  update: UserUpdateWithoutMenusDataInput
  upsert: UserUpsertWithoutMenusInput
}

input UserUpdateOneRequiredWithoutOrdersInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
}

input UserUpdateWithoutAddressesDataInput {
  createdAt: DateTime
  defaultAddress: DefaultAddressUpdateOneWithoutUserInput
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealUpdateManyWithoutUserInput
  menus: MenuUpdateManyWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpdateWithoutDefaultAddressDataInput {
  addresses: AddressUpdateManyWithoutUserInput
  createdAt: DateTime
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealUpdateManyWithoutUserInput
  menus: MenuUpdateManyWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpdateWithoutMealsDataInput {
  addresses: AddressUpdateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressUpdateOneWithoutUserInput
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  menus: MenuUpdateManyWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpdateWithoutMenusDataInput {
  addresses: AddressUpdateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressUpdateOneWithoutUserInput
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealUpdateManyWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpdateWithoutOrdersDataInput {
  addresses: AddressUpdateManyWithoutUserInput
  createdAt: DateTime
  defaultAddress: DefaultAddressUpdateOneWithoutUserInput
  email: String
  facebookId: String
  firstName: String
  googleId: String
  id: String
  lastName: String
  meals: MealUpdateManyWithoutUserInput
  menus: MenuUpdateManyWithoutUserInput
  password: String
  role: Role
  tokenVersion: String
  updatedAt: DateTime
}

input UserUpsertWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput!
  update: UserUpdateWithoutAddressesDataInput!
}

input UserUpsertWithoutDefaultAddressInput {
  create: UserCreateWithoutDefaultAddressInput!
  update: UserUpdateWithoutDefaultAddressDataInput!
}

input UserUpsertWithoutMealsInput {
  create: UserCreateWithoutMealsInput!
  update: UserUpdateWithoutMealsDataInput!
}

input UserUpsertWithoutMenusInput {
  create: UserCreateWithoutMenusInput!
  update: UserUpdateWithoutMenusDataInput!
}

input UserUpsertWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput!
  update: UserUpdateWithoutOrdersDataInput!
}

input UserWhereInput {
  addresses: AddressFilter
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  defaultAddress: DefaultAddressWhereInput
  email: StringFilter
  facebookId: NullableStringFilter
  firstName: NullableStringFilter
  googleId: NullableStringFilter
  id: StringFilter
  lastName: NullableStringFilter
  meals: MealFilter
  menus: MenuFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  orders: OrderFilter
  password: NullableStringFilter
  role: Role
  tokenVersion: StringFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  facebookId: String
  googleId: String
  id: String
}
